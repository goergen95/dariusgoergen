---
output:
 html_document:
   keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, python.reticulate = reticulate::eng_python)
library(reticulate)
use_condaenv("bufr2netcdf")
```


I recently came across the [EUMETSAT](https://navigator.eumetsat.int/product/EO:EUM:DAT:MSG:RIIE)
Regional Instability Index dataset which is shipped in the less known _BUFR_ format.
In this tutorial I am going to show how you can use Python to translate
_.bfr_ files to _.tiff_ files.
Besides the gdal library for writing, we will also need the [pyresample](https://pyresample.readthedocs.io/en/latest/)
and the [pybufr_ecmwf](https://github.com/jdkloe/pybufr-ecmwf) libraries.
_pyresample_ currently does not support the _.bfr_ format natively, however, it is 
very likely to be supported in the future. 

---

```{python libs}
import numpy as np
import gdal
import osr
import pyresample as pr
from pybufr_ecmwf.bufr import BUFRReader
```

The [BUFR format](https://www.wmo.int/pages/prog/www/WDM/Guides/Guide-binary-1A.html) 
is a standardized format defined by the World Meteorological Organization (WMO)
and it stands for **B**inary **U**niversal **F**orm for the **R**epresentation of
meteorological data. It is a self describing format, shipping data together with its meta
to be used by end users. Within a _.bfr_ file we find a number of _messages_ with
each of it having a specific number of _entries_. We will use the functionality
of the _pybufr_ecmwf_ library to read in the data.

```{python parameters}
file = "../assets/files/MSG2-SEVI-MSGRIIE-0101-0101-20160526000000.000000000Z-20160526000602-1403456.bfr"
# read the file
bufr = BUFRReader(file, warn_about_bufr_size = False, expand_flags = False)
# display number of messages
print("Number of messages: "+ str(bufr.num_msgs))

# initiate list with parameter names
names_units = []
for m, msg in enumerate(bufr):
 names_units.append(msg.get_names_and_units())

# show parameter names and units
print('\n'.join(map(str, names_units[0][0])))
bufr.close()
```

Based on the above output we can decide which parameters we are interested in and 
which metadata we are going to need. Say we are only interested in the parameter
_K Index_. We can see that the index for this dataset is 16. Also, since
we are interested in writing a _.tiff_ as output, the datasets of latitude and 
longitude are going to be of interest to us (index 13 and 14, respectively).
Note, that we are reopening the file once again, in order to start from the very 
first message.

```{python data}
# initiate arrays
lats = np.zeros([0])
lons = np.zeros([0])
vals = np.zeros([0])
# reopening the file
bufr = BUFRReader(file, warn_about_bufr_size = False, expand_flags = False)

# loop through the messages and sub-entries
for msg in bufr:
 for subs in msg:
  data = subs.data
  lats = np.append(lats, data[:,13])
  lons = np.append(lons, data[:,14])
  vals = np.append(vals, data[:,16])
# don't forget to close the file
bufr.close()
```

With this loop, we obtained all the necessary data to create a _.tiff_ file. We have
got the values we are interested in, as well as the geographic information of 
each location's latitude and longitude data. We can now use functionality from the
_pyresample_ library to resample our data to a location of interest. Let's say
we are interested in a studyarea roughly having the extent of France.
We can resample to this area, by declaring a area definition first.

```{python area_def}
# define some general properties of our projection
area_id = "France"
description = "Custom Geographical CRS of France"
proj_id = "France WGS84 geographical"
proj_dict = {"proj": "longlat", "ellps":"WGS84", "datum": "WGS84"}
# define the area's extent in degrees and desired resolution
llx = -4.9
lly = 42.2
urx = 8.2
ury = 51.2
res = 0.015 # in degrees
width = int((urx - llx) / res)
height = int((ury - lly) / res)
area_extent = (llx,lly,urx,ury)
area_def = pr.geometry.AreaDefinition(area_id, proj_id, description, proj_dict, width, height, area_extent)
print(area_def)
```

With this area definition we can resample our data using the nearest neighbor 
algorithm and use our defined variables about the location to create a _.tiff_ file 
as output.

```{python tif, results="hide"}
swath_def = pr.geometry.SwathDefinition(lons = lons, lats = lats)
res_data = pr.kd_tree.resample_nearest(swath_def, vals, area_def,
radius_of_influence=16000,epsilon=1000,fill_value=False)

# create tif output
filename = "../assets/files/bufr2tif.tif"
# number of rows and cols
rows = res_data.shape[0]
cols = res_data.shape[1]
# pixel size
pixelWidth = (area_def.area_extent[2] - area_def.area_extent[0]) / cols
pixelHeight = (area_def.area_extent[1] - area_def.area_extent[3]) / rows
# pixel of origin
originX = area_def.area_extent[0]
originY = area_def.area_extent[3]
# driver
driver = gdal.GetDriverByName("GTiff")
# create file 
outRaster = driver.Create(filename, cols, rows, 1, gdal.GDT_Float64)
# set resoultion and origin
outRaster.SetGeoTransform((originX, pixelWidth, 0, originY, 0, pixelHeight))
# create one band
outband = outRaster.GetRasterBand(1)
# Float_64 no data value (or customize)
outband.SetNoDataValue(1.7e+38)
# write the resampled data to file
outband.WriteArray(np.array(res_data))
# create a spatial reference system
outRasterSRS = osr.SpatialReference()
outRasterSRS.ImportFromEPSG(4326)
# write SRS to file
outRaster.SetProjection(outRasterSRS.ExportToWkt())
# clean up
outband.FlushCache()
outband = None
outRaster = None
```

--- 

Now we can read in the newly created file and take a look at a simple plot
to visualize our result. Note that, in the background I am using R to quickly generate
this plot.

```{r plot, echo = F, warning=F, message=F}
library(raster)
library(rnaturalearth)
r = raster("../assets/files/bufr2tif.tif")
names(r) = "K Index"
cnt = ne_countries()
cnt = crop(cnt, r)
plot(r, col = grey(1:250/250))
plot(cnt, add =T, border = "red")
```


