---
output:
 html_document:
   keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, python.reticulate = reticulate::eng_python)
library(reticulate)
use_condaenv("bufr2netcdf")
```


In this tutorial I am going to show how we can use Python to translate
.bufr files to .tiff files. The file used here is the MSG derived Regional
Instability Index from [EUMETSAT](https://navigator.eumetsat.int/product/EO:EUM:DAT:MSG:RIIE). 
Besides the gdal library, we will also need the [pyresample](https://pyresample.readthedocs.io/en/latest/)
and the [pybufr_ecmwf](https://github.com/jdkloe/pybufr-ecmwf) libraries.
Pyresample currently does not support the .bufr format nativley, however, it is 
very likley to be supported in the future. 

```{python libs}
import numpy as np
import gdal
import osr
import pyresample as pr
from pybufr_ecmwf.bufr import BUFRReader
import xarray as xr
import matplotlib.pyplot as plt
import cartopy
import cartopy.crs as ccrs
from affine import Affine
```
The [bufr format](https://www.wmo.int/pages/prog/www/WDM/Guides/Guide-binary-1A.html) 
is a standardized format defined by the World Meterological Organization (WMO)
and it stands for **B**inary **U**niversal **F**orm for the **R**epresentation of
meterological data. It is a self describing format, shipping data together with its meta
to be used by end users. Within a bufr file we wind a number of _messages_ with
each of it having a specific number of _entries_. We will use the functionality
of the pybufr_ecmwf library to read in the data.

```{python parameters}
file = "../assets/files/MSG2-SEVI-MSGRIIE-0101-0101-20160526000000.000000000Z-20160526000602-1403456.bfr"
# read the file
bufr = BUFRReader(file, warn_about_bufr_size = False, expand_flags = False)
# display number of messages
print("Number of messages: "+ str(bufr.num_msgs))

# initiate list with parameter names
names_units = []
for m, msg in enumerate(bufr):
 names_units.append(msg.get_names_and_units())

# show parameter names and units
print('\n'.join(map(str, names_units[0][0])))
bufr.close()
```
Based on the above output we can decide which parameters we are interested in and 
which metadata we are going to need. Say we are only interested in the parameter
_K Index_. We can see that the index for this dataset is number 16. Also, since
we are interested in having a .tif-file as output, the datasets of latitude and 
longitude are going to be of interest to us (index 13 and 14, respectively).
Note, that we are reopening the file once again, in order to start from the very 
first message.

```{python data}
lats = np.zeros([0])
lons = np.zeros([0])
vals = np.zeros([0])
bufr = BUFRReader(file, warn_about_bufr_size = False, expand_flags = False)

for msg in bufr:
 for subs in msg:
  data = subs.data
  lats = np.append(lats, data[:,13])
  lons = np.append(lons, data[:,14])
  vals = np.append(vals, data[:,16])
  
bufr.close()
```

With this loop, we obtained all the necessary data to create a .tif file. We have
got the values we are interested in, as well as the geographic information of 
each location's latitude and longitude data. We can now use functionality from the
_pyresample_ library to resample our data to a location of interest. Let's say
we are interested in a studyarea roughly having the extent of France.
We can resample to this area, by declaring a area defintion first.

```{python area_def}
# define some general properties of our projection
area_id = "France"
description = "Custom Geographical CRS of France"
proj_id = "France WGS84 geographical"
proj_dict = {"proj": "longlat", "ellps":"WGS84", "datum": "WGS84"}
# define the area's extent in degrees adn desired resolution
llx = -4.9
lly = 42.2
urx = 8.2
ury = 51.2
res = 0.03 # in degrees
width = int((urx - llx) / res)
height = int((ury - lly) / res)
area_extent = (llx,lly,urx,ury)
area_def = pr.geometry.AreaDefinition(area_id, proj_id, description, proj_dict, width, height, area_extent)
print(area_def)
```
With this area definition we can resample our data using the nearest neigbourh 
algorithm and use our defined variables to create a .tif file as output.

```{python tif, results="hide"}
swath_def = pr.geometry.SwathDefinition(lons = lons, lats = lats)
res_data = pr.kd_tree.resample_nearest(swath_def, vals, area_def,
radius_of_influence=16000,epsilon=1000,fill_value=False)

# create tif output
filename = "../assets/files/bufr2tif.tif"
# number of rows and cols
rows = res_data.shape[0]
cols = res_data.shape[1]
# pixel size
pixelWidth = (area_def.area_extent[2] - area_def.area_extent[0]) / cols
pixelHeight = (area_def.area_extent[1] - area_def.area_extent[3]) / rows
# pixel of origin
originX = area_def.area_extent[0]
originY = area_def.area_extent[3]
# driver
driver = gdal.GetDriverByName("GTiff")
# create file 
outRaster = driver.Create(filename, cols, rows, 1, gdal.GDT_Float64)
# set resoultion and origin
outRaster.SetGeoTransform((originX, pixelWidth, 0, originY, 0, pixelHeight))
# create one band
outband = outRaster.GetRasterBand(1)
# Float_64 no data value (or customize)
outband.SetNoDataValue(1.7e+38)
# write the resampled data to file
outband.WriteArray(np.array(res_data))
# create a spatial reference system
outRasterSRS = osr.SpatialReference()
outRasterSRS.ImportFromEPSG(4326)
# write SRS to file
outRaster.SetProjection(outRasterSRS.ExportToWkt())
# clean up
outband.FlushCache()
outband = None
outRaster = None
```
Now we can read in the newly created file and take a look at a simple plot
to visualize our result (Note that in the background I am using R to quickly generate
this plot).

```{r plot, echo = F, warning=F, message=F}
library(raster)
library(rnaturalearth)
r = raster("../assets/files/bufr2tif.tif")
names(r) = "K Index"
cnt = ne_countries()
cnt = crop(cnt, r)
plot(r)
plot(cnt, add =T)
```


