{
  "hash": "4778b696ac3b6e3aeadb975ea77b2730",
  "result": {
    "markdown": "---\ntitle: \"Translating EUMETSAT's .bfr files to GTiff\"\ndescription: \"Python code to translate EUMETSAT's BUFR datasets to GTiffs.\"\ndate: 2020-05-01 09:00\nauthor: \"Darius A. GÃ¶rgen\"\ncategories: [\"BUFR\", \"TIFF\", \"Python\"]\nimage: eumetsat-logo.jpg\n---\n\nI recently came across the [EUMETSAT](https://navigator.eumetsat.int/product/EO:EUM:DAT:MSG:RIIE)\nRegional Instability Index dataset, which is shipped in the less known _BUFR_ format.\nIn this tutorial, I am going to show how you can use Python to translate\n_.bfr_ files to _.tiff_ files.\nBesides the GDAL library for writing, we will also need the [pyresample](https://pyresample.readthedocs.io/en/latest/)\nand the [pybufr_ecmwf](https://github.com/jdkloe/pybufr-ecmwf) libraries.\n_pyresample_ currently does not support the _.bfr_ format natively. However, it is \nvery likely to be supported in the future. \n\n---\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nfrom osgeo import gdal\nfrom osgeo import osr\nimport pyresample as pr\nfrom pybufr_ecmwf.bufr import BUFRReader\nimport matplotlib.pyplot as plt\n```\n:::\n\n\nThe [BUFR format](https://www.wmo.int/pages/prog/www/WDM/Guides/Guide-binary-1A.html) \nis a standardized format defined by the World Meteorological Organization (WMO).\nIt stands for **B**inary **U**niversal **F**orm for the **R**epresentation of\nmeteorological data. It is a self-describing format, shipping data together with metadata\nto be used by end-users. Within a _.bfr_ file, we find several _messages_,\neach of them having a specific number of _entries_. We will use the functionality\nof the _pybufr_ecmwf_ library to read in the data.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfile = \"MSG2-SEVI-MSGRIIE-0101-0101-20160526000000.000000000Z-20160526000602-1403456.bfr\"\n# read the file\nbufr = BUFRReader(file, warn_about_bufr_size = False, expand_flags = False)\n# display number of messages\nprint(\"Number of messages: \"+ str(bufr.num_msgs))\n\n# initiate list with parameter names\nnames_units = []\nfor m, msg in enumerate(bufr):\n names_units.append(msg.get_names_and_units())\n\n# show parameter names and units\nprint('\\n'.join(map(str, names_units[0][0])))\n# close file\nbufr.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of messages: 90\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nSATELLITE IDENTIFIER\nIDENTIFICATION OF ORIGINATING/GENERATING CENTRE (SEE NOTE 10)\nSATELLITE CLASSIFICATION\nSEGMENT SIZE AT NADIR IN X DIRECTION\nSEGMENT SIZE AT NADIR IN Y DIRECTION\nYEAR\nMONTH\nDAY\nHOUR\nMINUTE\nSECOND\nROW NUMBER\nCOLUMN NUMBER\nLATITUDE (HIGH ACCURACY)\nLONGITUDE (HIGH ACCURACY)\nSATELLITE ZENITH ANGLE\nK INDEX\nKO INDEX\nPARCEL LIFTED INDEX (TO 500 HPA)\nMAXIMUM BUOYANCY\nPRECIPITABLE WATER\nPER CENT CONFIDENCE\nPRESSURE\nPRESSURE\nPRECIPITABLE WATER\nPRESSURE\nPRESSURE\nPRECIPITABLE WATER\nPRESSURE\nPRESSURE\nPRECIPITABLE WATER\n```\n:::\n:::\n\n\nBased on the above output, we can decide which parameters we are interested in and \nwhich metadata we will need. Say we are only interested in the parameter\n_K Index_. We can see that the index for this dataset is 16. Also, since\nwe are interested in writing a _.tiff_ as output, the datasets of latitude and \nlongitude will be of interest to us (index 13 and 14, respectively).\nNote that we are reopening the file once again to start from the very \nfirst message.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# initiate arrays\nlats = np.zeros([0])\nlons = np.zeros([0])\nvals = np.zeros([0])\n# reopening the file\nbufr = BUFRReader(file, warn_about_bufr_size = False, expand_flags = False)\n\n# loop through the messages and sub-entries\nfor msg in bufr:\n for subs in msg:\n  data = subs.data\n  lats = np.append(lats, data[:,13])\n  lons = np.append(lons, data[:,14])\n  vals = np.append(vals, data[:,20])\n# don't forget to close the file\nbufr.close()\nvals = np.where(vals == np.max(vals), -9999, vals)\n```\n:::\n\n\nWith this loop, we obtained all the necessary data to create a _.tiff_ file. We have\ngot the values we are interested in and the geographic information of \neach location's latitude and longitude data. We can now use the\n_pyresample_ library to resample our data to a location of interest. Let's say\nwe are interested in a study area roughly having the extent of France.\nWe can resample to this area by declaring an area definition first.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# define some general properties of our projection\narea_id = \"France\"\ndescription = \"Custom Geographical CRS of France\"\nproj_id = \"France WGS84 geographical\"\nproj_dict = {\"proj\": \"longlat\", \"ellps\":\"WGS84\", \"datum\": \"WGS84\"}\n# define the area's extent in degrees and desired resolution\nllx = -4.9\nlly = 42.2\nurx = 8.2\nury = 51.2\nres = 0.015 # in degrees\nwidth = int((urx - llx) / res)\nheight = int((ury - lly) / res)\narea_extent = (llx,lly,urx,ury)\narea_def = pr.geometry.AreaDefinition(area_id, proj_id, description, proj_dict, width, height, area_extent)\nprint(area_def)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArea ID: France\nDescription: France WGS84 geographical\nProjection ID: Custom Geographical CRS of France\nProjection: {'datum': 'WGS84', 'no_defs': 'None', 'proj': 'longlat', 'type': 'crs'}\nNumber of columns: 873\nNumber of rows: 600\nArea extent: (-4.9, 42.2, 8.2, 51.2)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/home/darius/Desktop/website/new/py-env/lib/python3.10/site-packages/pyproj/crs/crs.py:1282: UserWarning: You will likely lose important projection information when converting to a PROJ string from another format. See: https://proj.org/faq.html#what-is-the-best-format-for-describing-coordinate-reference-systems\n  proj = self._crs.to_proj4(version=version)\n```\n:::\n:::\n\n\nWith this area definition, we can resample our data using the nearest neighbor \nalgorithm and use our defined variables about the location to create a _.tiff_ file \nas output.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nswath_def = pr.geometry.SwathDefinition(lons = lons, lats = lats)\nres_data = pr.kd_tree.resample_nearest(swath_def, vals, area_def,\nradius_of_influence=16000,epsilon=0.5,fill_value=False)\n\n# create tif output\nfilename = \"bufr2tif.tif\"\n# number of rows and cols\nrows = res_data.shape[0]\ncols = res_data.shape[1]\n# pixel size\npixelWidth = (area_def.area_extent[2] - area_def.area_extent[0]) / cols\npixelHeight = (area_def.area_extent[1] - area_def.area_extent[3]) / rows\n# pixel of origin\noriginX = area_def.area_extent[0]\noriginY = area_def.area_extent[3]\n# driver\ndriver = gdal.GetDriverByName(\"GTiff\")\n# create file \noutRaster = driver.Create(filename, cols, rows, 1, gdal.GDT_Float32)\n# set resoultion and origin\noutRaster.SetGeoTransform((originX, pixelWidth, 0, originY, 0, pixelHeight))\n# create one band\noutband = outRaster.GetRasterBand(1)\n# Float_64 no data value (or customize)\noutband.SetNoDataValue(-9999)\n# write the resampled data to file\noutband.WriteArray(np.array(res_data))\n# create a spatial reference system\noutRasterSRS = osr.SpatialReference()\noutRasterSRS.ImportFromEPSG(4326)\n# write SRS to file\noutRaster.SetProjection(outRasterSRS.ExportToWkt())\n# clean up\noutband.FlushCache()\noutband = None\noutRaster = None\n```\n:::\n\n\n--- \n\nNow we can read in the newly created file and look at a simple plot\nto visualize our result. Note that, in the background, I am using R to generate\nthis plot quickly.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nfile = \"bufr2tif.tif\"\nds = gdal.Open(file)\nband = ds.GetRasterBand(1)\ndata = band.ReadAsArray()\ndata = np.where(data == -9999., np.NaN, data)\nplt.imshow(data)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n<matplotlib.image.AxesImage at 0x7f4afc87fb80>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-7-output-2.png){width=575 height=404}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}