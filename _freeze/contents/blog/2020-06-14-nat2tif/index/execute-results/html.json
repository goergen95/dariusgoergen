{
  "hash": "fd2ab247c6644c1df43d1d7aa6ff3e7c",
  "result": {
    "markdown": "---\ntitle: Translating EUMETSAT's .nat files to GTiff\ndescription: Python code to translate EUMETSAT's .nat datasets to GTiffs.\ndate: '2020-05-10 10:00'\nauthor: Darius A. GÃ¶rgen\ncategories:\n  - MSG\n  - GTIFF\n  - Python\nimage: eumetsat-logo.jpg\n---\n\nIn this tutorial, I am using Python to translate a Meteosat Second Generation (MSG) Native Archive Format (.nat) file to GTiff. Conveniently, there exists a\ndriver support for these files in both, the [gdal](https://gdal.org/drivers/raster/msgn.html) \nand the [satpy](https://satpy.readthedocs.io/en/latest/index.html) library.\nHere, we are going to use satpy because we also want to resample the data\nwith its \"associated\" library [pyresample](https://pyresample.readthedocs.io/en/latest/). \nFirst, we will load all the libraries we are going to need into our Python session.\n\n::: {#libs .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nfrom osgeo import gdal\nfrom osgeo import osr\nimport os\nimport pyresample as pr\nfrom satpy import Scene\nimport matplotlib.pyplot as plt\n```\n:::\n\n\nAs opposed to BUFR files, reading _.nat_ files is quite straightforward. All we need to do is \nhanding the right reader to the satpy _Scene_ function. We can then take a look\nat the available datasets.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfile = \"MSG1-SEVI-MSG15-0100-NA-20160531090417.660000000Z-20160531090437-1405098.nat\"\n# define reader\nreader = \"seviri_l1b_native\"\n# read the file\nscn = Scene(filenames = {reader:[file]})\n# extract data set names\ndataset_names = scn.all_dataset_names()\n# print available datasets\nprint('\\n'.join(map(str, dataset_names)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHRV\nIR_016\nIR_039\nIR_087\nIR_097\nIR_108\nIR_120\nIR_134\nVIS006\nVIS008\nWV_062\nWV_073\n```\n:::\n:::\n\n\nThe MSG data is provided as Full Disk, meaning that roughly the complete North-South\nextent of the globe from the Atlantic to the Indian Ocean is present in \neach file. For most applications and research questions, it is not necessary\nto process an extent that large. This is why as an example, we are going to resample\nthe data to the extent of Spain. For this, we are using functionality \nfrom the _pyresample_ library, which allows users to create customized area definitions.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# create some information on the reference system\narea_id = \"Spain\"\ndescription = \"Geographical Coordinate System clipped on Spain\"\nproj_id = \"Spain\"\n# specifing some parameters of the projection\nproj_dict = {\"proj\": \"longlat\", \"ellps\": \"WGS84\", \"datum\": \"WGS84\"}\n# calculate the width and height of the aoi in pixels\nllx = -9.5 # lower left x coordinate in degrees\nlly = 35.9 # lower left y coordinate in degrees\nurx = 3.3 # upper right x coordinate in degrees\nury = 43.8 # upper right y coordinate in degrees\nresolution = 0.005 # target resolution in degrees\n# calculating the number of pixels\nwidth = int((urx - llx) / resolution)\nheight = int((ury - lly) / resolution)\narea_extent = (llx,lly,urx,ury)\n# defining the area\narea_def = pr.geometry.AreaDefinition(area_id, proj_id, description, proj_dict, width, height, area_extent)\nprint(area_def)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArea ID: Spain\nDescription: Spain\nProjection ID: Geographical Coordinate System clipped on Spain\nProjection: {'datum': 'WGS84', 'no_defs': 'None', 'proj': 'longlat', 'type': 'crs'}\nNumber of columns: 2560\nNumber of rows: 1579\nArea extent: (-9.5, 35.9, 3.3, 43.8)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/home/darius/Desktop/website/new/py-env/lib/python3.10/site-packages/pyproj/crs/crs.py:1282: UserWarning: You will likely lose important projection information when converting to a PROJ string from another format. See: https://proj.org/faq.html#what-is-the-best-format-for-describing-coordinate-reference-systems\n  proj = self._crs.to_proj4(version=version)\n```\n:::\n:::\n\n\nWe will show here how to proceed when we want to extract more\nthan one specific data set. We can either apply a for loop\nover the desired datasets we need or write a general function that can extract the data for any specified variable. Here we are going forward with\nthe latter approach because a function is more reusable than a \nsimple script.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef nat2tif(file, calibration, area_def, dataset, reader, outdir, label, dtype, radius, epsilon, nodata):\n  # open the file\n  scn = Scene(filenames = {reader: [file]})\n  # let us check that the specified data set is actually available\n  scn_names = scn.all_dataset_names()\n  # raise exception if dataset is not present in available names\n  if dataset not in scn_names:\n    raise Exception(\"Specified dataset is not available.\")\n  # we need to load the data, different calibration can be chosen\n  scn.load([dataset], calibration=calibration)\n  # let us extract the longitude and latitude data\n  lons, lats = scn[dataset].area.get_lonlats()\n  # now we can apply a swath definition for our output raster\n  swath_def = pr.geometry.SwathDefinition(lons=lons, lats=lats)\n  # and finally we also extract the data\n  values = scn[dataset].values\n  # we will now change the datatype of the arrays\n  # depending on the present data this can be changed\n  lons = lons.astype(dtype)\n  lats = lats.astype(dtype)\n  values = values.astype(dtype)\n  # now we can already resample our data to the area of interest\n  values = pr.kd_tree.resample_nearest(swath_def, values,\n                                             area_def,\n                                             radius_of_influence=radius, # in meters\n                                             epsilon=epsilon,\n                                             fill_value=False)\n  # we are going to check if the outdir exists and create it if it doesnt\n  if not os.path.exists(outdir):\n   os.makedirs(outdir)\n  # let us join our filename based on the input file's basename                                           \n  outname = os.path.join(outdir, os.path.basename(file)[:-4] + \"_\" + str(label) + \".tif\")\n  # now we define some metadata for our raster file\n  cols = values.shape[1]\n  rows = values.shape[0]\n  pixelWidth = (area_def.area_extent[2] - area_def.area_extent[0]) / cols\n  pixelHeight = (area_def.area_extent[1] - area_def.area_extent[3]) / rows\n  originX = area_def.area_extent[0]\n  originY = area_def.area_extent[3] \n  # here we actually create the file\n  driver = gdal.GetDriverByName(\"GTiff\")\n  outRaster = driver.Create(outname, cols, rows, 1)\n  # writing the metadata\n  outRaster.SetGeoTransform((originX, pixelWidth, 0, originY, 0, pixelHeight))\n  # creating a new band and writting the data\n  outband = outRaster.GetRasterBand(1)\n  outband.SetNoDataValue(nodata) #specified no data value by user\n  outband.WriteArray(np.array(values)) # writting the values\n  outRasterSRS = osr.SpatialReference() # create CRS instance\n  outRasterSRS.ImportFromEPSG(4326) # get info for EPSG 4326\n  outRaster.SetProjection(outRasterSRS.ExportToWkt()) # set CRS as WKT\n  # clean up\n  outband.FlushCache()\n  outband = None\n  outRaster = None\n\n```\n:::\n\n\nNow we can apply this function to our input file and extract any available dataset. Note that some of the input variables need further explanation.\nThe very first option which might not be self-evident is calibration. With this \noption we can tell satpy to pre-calibrate the data, for example, to reflectance in\ncontrast to radiances. The option _label_ appends the value of label to the \nouput filename. With the _dtype_ option, we can specifically choose which datatype\nis used for the output file. Accordingly, we should adopt the value for nodata,\nwhich flags no data values in the output file.\nThe options _radius_ and _epsilon_ are options of the nearest neighbor resampling\nroutine and can be specified to the user needs (see [here](https://pyresample.readthedocs.io/en/latest/swath.html#pyresample-kd-tree) for more information).\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nnat2tif(file = file, \n        calibration = \"radiance\",  \n        area_def = area_def,  \n        dataset = \"HRV\", \n        reader = reader, \n        outdir = \"./output\",  \n        label = \"HRV\", \n        dtype = \"float32\", \n        radius = 16000, \n        epsilon = .5, \n        nodata = -3.4E+38)\n```\n:::\n\n\nNow we can read in the newly created file and take a look at a simple plot\nto visualize our result (Note that in the background, I am using R to generate this plot quickly).\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nfile = \"output/MSG1-SEVI-MSG15-0100-NA-20160531090417.660000000Z-20160531090437-1405098_HRV.tif\"\nds = gdal.Open(file)\nband = ds.GetRasterBand(1)\ndata = band.ReadAsArray()\nplt.imshow(data)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n<matplotlib.image.AxesImage at 0x7f54fa1e1c90>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-7-output-2.png){width=588 height=368}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}